<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    background-color: black;
}
html, body {
    overflow: hidden;
}
body {
  background: black;
}
</style>
</head>

<body onload="startGame()">

<img src="pic/pirate.png" id="pirate" style="display: none;">
<img src="pic/water.jpg" id="water" style="display: none;">
<img src="pic/water2.jpg" id="water2" style="display: none;">

<script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
<script>

var person = prompt("Please enter your name");
var personId=Math.floor(Math.random()*100);
//var person = "ship";

var socket = io();

var myGamePiece = new myShip(Math.floor(Math.random()*1025), Math.floor(Math.random()*1025), person);
var otherShips=new Array();
var balls=new Array();


var receivedData1;
var receivedData2;

// node js connection to data from server
// ships
socket.on('data1', function(msg1){
  receivedData1=msg1;
});
// creating balls
socket.on('data2', function(msg2){
  receivedData2=msg2;
});


// rounding numbers function
function round(n, k){
    var factor = Math.pow(10, k);
    return Math.round(n*factor)/factor;
}



// interval for data receiving
function dataS1() {
setInterval(function(){

  // receiving positions
  if(receivedData1!=null&&receivedData1.id!=myGamePiece.id){
    // checking if the ship is allready on the map
    var newPiece=true;
    for(var x=0; x<otherShips.length; x++){
      if(otherShips[x].id==receivedData1.id){
        otherShips[x].update(receivedData1.x, receivedData1.y, receivedData1.a, receivedData1.hp);
        newPiece=false;
      }
    }
    if(newPiece){
      otherShips.push(new otherShip(receivedData1.x, receivedData1.y,
      receivedData1.a, receivedData1.id, receivedData1.n, receivedData1.hp));
    }
    receivedData1=null;
  }


  if(receivedData2!=null){
    balls.push(new ball(receivedData2.x, receivedData2.y, receivedData2.a));
    receivedData2=null;
  }

}, 1);
}

// interval for data sending
function dataR1() {
setInterval(function(){

  // sending your position
  var data={"id":myGamePiece.id,"x":round(myGamePiece.x, 0),"y":round(myGamePiece.y, 0),
  "a":round(myGamePiece.angle, 4),"n":myGamePiece.name,"hp":myGamePiece.hp};
  socket.emit('data1', data);

}, 50);
}

// running functions to collect data
for(var l=0; l<1; l++){
  dataS1();
}

// running functions to send data
dataR1();




function updateGameArea() {

    myGameArea.clear();

    var ctx = myGameArea.context;
    ctx.drawImage(water, window.innerWidth/2-myGamePiece.x, window.innerHeight/2-myGamePiece.y);

    // user ship update
    myGamePiece.update();

    // showing other ships
    if(otherShips.length>0){
      for(var x=0; x<otherShips.length; x++){
          otherShips[x].show();
          if(otherShips[x].timer<=0){
            otherShips.splice(x,1);
          }
      }
    }


    // showing balls
    if(balls.length>0){
      for(var x=0; x<balls.length; x++){
          balls[x].show();
      }
    }
    // deleting balls when timer is zero
    if(balls.length>0){
      for(var x=0; x<balls.length; x++){
          if(balls[x].timer<=0){
            balls.splice(x,1);
          }
      }
    }

    // checking if player was hit
    if(balls.length>0){
      for(var x=0; x<balls.length; x++){
          if(Math.abs(balls[x].x-myGamePiece.x)<20 && Math.abs(balls[x].y-myGamePiece.y)<20 && balls[x].active){
            myGamePiece.hp-=20;
            balls.splice(x,1);
          }
      }
    }

    // checking if other ship was hit
    if(balls.length>0&&otherShips.length>0){
      for(var z=0; z<otherShips.length; z++){
        for(var x=0; x<balls.length; x++){
          if(Math.abs(balls[x].x-otherShips[z].x)<20 && Math.abs(balls[x].y-otherShips[z].y)<20 && balls[x].active){
            balls.splice(x,1);
          }
        }
      }
    }


    // checking if player died
    if(myGamePiece.hp<=0){
      myGamePiece = new myShip(Math.floor(Math.random()*1025), Math.floor(Math.random()*1025), person);
    }




}// end of game update



function myShip( x, y, name) {

    this.id=personId;
    this.name=name;
    this.hp=100;

    this.speed = 0;
    this.angle = 0;
    this.moveAngle = 0;

    this.x = x;
    this.y = y;

    // shooting
    this.timerS=0;
    this.shot;

    this.update = function() {

        this.speed = 0;
        this.moveAngle = 0;

        // shooting and sending data
        if(myGameArea.keys && myGameArea.keys[32]&&this.timerS==0){
          this.shot={"x":round(this.x, 0),"y":round(this.y, 0),
          "a":round(this.angle+( (Math.round(Math.random() * (20)) - 10) * Math.PI / 180), 4)};
          socket.emit('data2', this.shot);
          this.timerS=30;
        }

        if(this.timerS>0){
          this.timerS--;
        }


        if(myGameArea.keys && myGameArea.keys[40]){
          this.speed= 1;
        }
        if(myGameArea.keys && myGameArea.keys[38]){
          this.speed= -1;
        }
        if(myGameArea.keys && myGameArea.keys[37] ){
          this.moveAngle = -1;
        }
        if(myGameArea.keys && myGameArea.keys[39] ){
          this.moveAngle = 1;
        }

        // map border detection
        if(myGamePiece.x<0){
          myGamePiece.x=0;
        }
        if(myGamePiece.x>1024){
          myGamePiece.x=1024;
        }
        if(myGamePiece.y<0){
          myGamePiece.y=0;
        }
        if(myGamePiece.y>1024){
          myGamePiece.y=1024;
        }



        // changing position
        this.angle += this.moveAngle * Math.PI / 180;
        this.x -= this.speed * Math.sin(this.angle);
        this.y += this.speed * Math.cos(this.angle);

        ctx = myGameArea.context;
        ctx.save();
        ctx.translate(window.innerWidth/2, window.innerHeight/2);
        ctx.rotate(this.angle);
        ctx.drawImage(pirate, -50, -50);
        //ctx.fillStyle = "red";
        //ctx.fillRect(30 / -2, 60 / -2, 30, 60);
        ctx.restore();

        ctx.font = "bold 20px Courier New";
        ctx.fillStyle = "white";
        ctx.fillText("HP:"+this.hp,window.innerWidth/2-30,window.innerHeight/2-50);
        ctx.fillText(this.name,window.innerWidth/2-30,window.innerHeight/2-80);

    }
}





function otherShip( x, y, a, id, name, hp) {

    this.id=id;
    this.name=name;
    this.hp=hp;

    this.speed = 0;
    this.angle = a;
    this.moveAngle = 0;

    this.x = x;
    this.y = y;
    this.targetX=x;
    this.targetY=y;


    // time before object will be removed
    this.timer=50;


    this.update = function(newX, newY, newA, newHp) {

      this.targetX = newX;
      this.targetY = newY;
      this.targetA = newA;
      this.hp=newHp;

      // if the ship is far away from its target move it directly
      if(Math.abs(newX-this.x)>50||Math.abs(newY-this.y)>50){
        this.x = newX;
        this.y = newY;
      }

      // if ship angle is very different to target angle for more then 0.5 radian change it directly
      if(Math.abs(newA-this.angle)>0.5){
        this.angle = newA;
      }

        this.timer=50;
    }


    this.show = function() {

      if(this.targetX>this.x){
        this.x+=1;
      }
      if(this.targetX<this.x){
        this.x-=1;
      }
      if(this.targetY>this.y){
        this.y+=1;
      }
      if(this.targetY<this.y){
        this.y-=1;
      }


      if(this.targetA>this.angle){
        this.moveAngle=1;
      }
      if(this.targetA<this.angle){
        this.moveAngle=-1;
      }
      if(Math.abs(this.targetA-this.angle)<0.05){
        this.moveAngle=0;
      }


      this.angle += this.moveAngle * Math.PI / 180;

      ctx = myGameArea.context;
      ctx.save();
      ctx.translate(window.innerWidth/2-myGamePiece.x+this.x,window.innerHeight/2-myGamePiece.y+this.y);
      ctx.rotate(this.angle);
      ctx.drawImage(pirate, -50, -50);
      //ctx.fillStyle = "blue";
      //ctx.fillRect(30 / -2, 60 / -2, 30, 60);
      ctx.restore();

      ctx.font = "bold 20px Courier New";
      ctx.fillStyle = "white";
      ctx.fillText("HP:"+this.hp,window.innerWidth/2-myGamePiece.x+this.x-30,window.innerHeight/2-myGamePiece.y+this.y-50);
      ctx.fillText(this.name,window.innerWidth/2-myGamePiece.x+this.x-30,window.innerHeight/2-myGamePiece.y+this.y-80);

      this.timer--;

    }
}






function ball( x, y, a) {

    this.speed = 5;
    this.angle = a;
    this.timer=70;
    this.x = x;
    this.y = y;

    this.active=false;


    this.show = function() {

      this.x += this.speed * Math.sin(this.angle);
      this.y -= this.speed * Math.cos(this.angle);

      ctx = myGameArea.context;
      ctx.save();
      ctx.translate(window.innerWidth/2-myGamePiece.x+this.x,window.innerHeight/2-myGamePiece.y+this.y);
      ctx.rotate(this.angle);
      ctx.beginPath();
      ctx.translate(0, 0);

      ctx.fillStyle = "black";
      // make ball active to hurt other units
      if(this.timer<60){
        this.active=true;
        //ctx.fillStyle = "red";
      }

      ctx.arc(0, 0, 4, 0, 2*Math.PI);
      ctx.closePath();
      ctx.fill();
      ctx.restore();


      this.timer--;

    }
}




















//// MAIN GAME INTERVAL FUNCTION FOR CANVAS

function startGame() {
    myGameArea.start();
}


var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
        window.addEventListener('keyup', function (e) {
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
    },
    stop : function() {
        clearInterval(this.interval);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

</script>






</body>
</html>
