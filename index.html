<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    background-color: black;
}
html, body {
    overflow: hidden;
}
body {
  background: black;
}
</style>
</head>

<body onload="startGame()">

<img src="pic/pirate.png" id="pirate" style="display: none;">
<img src="pic/water.jpg" id="water" style="display: none;">
<img src="pic/water2.jpg" id="water2" style="display: none;">

<script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
<script>

//var person = prompt("Please enter your name");
var person = "ship";

var numberOfPlayers=4;

var socket = io();

var tempId=100;
var myGamePiece = new myShip(Math.floor(Math.random()*1025), Math.floor(Math.random()*1025),
person, tempId);


var otherShips=new Array();
var balls=new Array();

var firstConnection=true;

// ships data
var receivedShip1;
var receivedShip2;
var receivedShip3;
var receivedShip4;

// balls data
var receivedBall1;
var receivedBall2;
var receivedBall3;
var receivedBall4;

// node js connection to data from server
// ships sockets
socket.on('id1', function(ship1){
  receivedShip1=ship1;
});
socket.on('id2', function(ship2){
  receivedShip2=ship2;
});
socket.on('id3', function(ship3){
  receivedShip3=ship3;
});
socket.on('id4', function(ship4){
  receivedShip4=ship4;
});



// creating balls
// ship1
socket.on('data1', function(ball1){
  receivedBall1=ball1;
});
// ship2
socket.on('data2', function(ball2){
  receivedBall2=ball2;
});
// ship3
socket.on('data3', function(ball3){
  receivedBall3=ball3;
});
// ship4
socket.on('data4', function(ball4){
  receivedBall4=ball4;
});


// rounding numbers function
function round(n, k){
    var factor = Math.pow(10, k);
    return Math.round(n*factor)/factor;
}



// interval for data receiving
function dataS1() {
setInterval(function(){

  // receiving positions

  // ship1
  if(receivedShip1!=null&&receivedShip1.id!=myGamePiece.id){
    // checking if the ship is allready on the map
    var newPiece=true;
    for(var x=0; x<otherShips.length; x++){
      if(otherShips[x].id==receivedShip1.id){
        otherShips[x].update(receivedShip1.x, receivedShip1.y, receivedShip1.a, receivedShip1.hp);
        newPiece=false;
      }
    }
    if(newPiece){
      otherShips.push(new otherShip(receivedShip1.x, receivedShip1.y,
      receivedShip1.a, receivedShip1.id, receivedShip1.n, receivedShip1.hp));
    }
    receivedShip1=null;
  }

  // ship2
  if(receivedShip2!=null&&receivedShip2.id!=myGamePiece.id){
    // checking if the ship is allready on the map
    var newPiece=true;
    for(var x=0; x<otherShips.length; x++){
      if(otherShips[x].id==receivedShip2.id){
        otherShips[x].update(receivedShip2.x, receivedShip2.y, receivedShip2.a, receivedShip2.hp);
        newPiece=false;
      }
    }
    if(newPiece){
      otherShips.push(new otherShip(receivedShip2.x, receivedShip2.y,
      receivedShip2.a, receivedShip2.id, receivedShip2.n, receivedShip2.hp));
    }
    receivedShip2=null;
  }

  // ship3
  if(receivedShip3!=null&&receivedShip3.id!=myGamePiece.id){
    // checking if the ship is allready on the map
    var newPiece=true;
    for(var x=0; x<otherShips.length; x++){
      if(otherShips[x].id==receivedShip3.id){
        otherShips[x].update(receivedShip3.x, receivedShip3.y, receivedShip3.a, receivedShip3.hp);
        newPiece=false;
      }
    }
    if(newPiece){
      otherShips.push(new otherShip(receivedShip3.x, receivedShip3.y,
      receivedShip3.a, receivedShip3.id, receivedShip3.n, receivedShip3.hp));
    }
    receivedShip3=null;
  }

  // ship4
  if(receivedShip4!=null&&receivedShip4.id!=myGamePiece.id){
    // checking if the ship is allready on the map
    var newPiece=true;
    for(var x=0; x<otherShips.length; x++){
      if(otherShips[x].id==receivedShip4.id){
        otherShips[x].update(receivedShip4.x, receivedShip4.y, receivedShip4.a, receivedShip4.hp);
        newPiece=false;
      }
    }
    if(newPiece){
      otherShips.push(new otherShip(receivedShip4.x, receivedShip4.y,
      receivedShip4.a, receivedShip4.id, receivedShip4.n, receivedShip4.hp));
    }
    receivedShip4=null;
  }


  // receiving balls
  if(receivedBall1!=null){
    balls.push(new ball(receivedBall1.x, receivedBall1.y, receivedBall1.a, 1));
    receivedBall1=null;
  }
  if(receivedBall2!=null){
    balls.push(new ball(receivedBall2.x, receivedBall2.y, receivedBall2.a, 2));
    receivedBall2=null;
  }
  if(receivedBall3!=null){
    balls.push(new ball(receivedBall3.x, receivedBall3.y, receivedBall3.a, 3));
    receivedBall3=null;
  }
  if(receivedBall4!=null){
    balls.push(new ball(receivedBall4.x, receivedBall4.y, receivedBall4.a, 4));
    receivedBall4=null;
  }

}, 10);
}

// interval for data sending
function dataR1() {
setInterval(function(){


  // sending your position
  if(myGamePiece.id==1){
    var ship1={"id":myGamePiece.id,"x":round(myGamePiece.x, 0),"y":round(myGamePiece.y, 0),
    "a":round(myGamePiece.angle, 4),"n":myGamePiece.name,"hp":myGamePiece.hp};
    socket.emit('id1', ship1);
  }
  if(myGamePiece.id==2){
    var ship2={"id":myGamePiece.id,"x":round(myGamePiece.x, 0),"y":round(myGamePiece.y, 0),
    "a":round(myGamePiece.angle, 4),"n":myGamePiece.name,"hp":myGamePiece.hp};
    socket.emit('id2', ship2);
  }
  if(myGamePiece.id==3){
    var ship3={"id":myGamePiece.id,"x":round(myGamePiece.x, 0),"y":round(myGamePiece.y, 0),
    "a":round(myGamePiece.angle, 4),"n":myGamePiece.name,"hp":myGamePiece.hp};
    socket.emit('id3', ship3);
  }
  if(myGamePiece.id==4){
    var ship4={"id":myGamePiece.id,"x":round(myGamePiece.x, 0),"y":round(myGamePiece.y, 0),
    "a":round(myGamePiece.angle, 4),"n":myGamePiece.name,"hp":myGamePiece.hp};
    socket.emit('id4', ship4);
  }



}, 100);
}

// running functions to collect data
for(var l=0; l<1; l++){
  dataS1();
}

// running functions to send data
dataR1();



///////////////////////////////////// MAIN CANVAS INTERVAL FUNCTION
function updateGameArea() {



    myGameArea.clear();

    var ctx = myGameArea.context;
    ctx.drawImage(water, window.innerWidth/2-myGamePiece.x, window.innerHeight/2-myGamePiece.y);




    // connecting player and setting id
    if(firstConnection){
    // give time to gather data about existing players, delay time 1-2 seconds random
      setTimeout(function(){
         firstConnection=false;
      }, (Math.floor(Math.random() * 1000)+1000));
    }else{
    // adjusting id to ship, 4 ships allowed
    if(myGamePiece.id>numberOfPlayers){

      // if there are other ships in the game set tempId different then the ones present
      if(otherShips.length>0){
        var proposition=1;
        for(var g=0; g<numberOfPlayers; g++){
          var ifProp=true;
          for(var z=0; z<otherShips.length; z++){
            if(otherShips[z].id==proposition){
              ifProp=false;
            }
          }
          if(ifProp==false){
            proposition++;
          }else{
            myGamePiece=new myShip(Math.floor(Math.random()*1025), Math.floor(Math.random()*1025),
            person, tempId);
            myGamePiece.id=proposition;
            tempId=proposition;
            break;
          }
        }
        // id=100 means player is connecting
        // id=200 means player is waiting for its place in the game
        if(myGamePiece.id==100){
          myGamePiece.id=200;
        }
      // if player is the only ship in the game, give id=1
      }else{
        myGamePiece=new myShip(Math.floor(Math.random()*1025), Math.floor(Math.random()*1025),
        person, tempId);
        myGamePiece.id=1;
        tempId=1;
      }
     }
    }
    // if player has the same if like other ship, give some time by changing
    // firstConnection variable
    if(otherShips.length>0){
      for(var z=0; z<otherShips.length; z++){
        if(otherShips[z].id==myGamePiece.id){
          firstConnection=true;
        }
      }
    }




    // user ship update
    myGamePiece.update();

    // showing other ships
    if(otherShips.length>0){
      for(var x=0; x<otherShips.length; x++){
          otherShips[x].show();
          if(otherShips[x].timer<=0){
            otherShips.splice(x,1);
          }
      }
    }


    // showing balls
    if(balls.length>0){
      for(var x=0; x<balls.length; x++){
          balls[x].show();
      }
    }
    // deleting balls when timer is zero
    if(balls.length>0){
      for(var x=0; x<balls.length; x++){
          if(balls[x].timer<=0){
            balls.splice(x,1);
          }
      }
    }

    // checking if player was hit
    if(balls.length>0&&myGamePiece.inGame){
      for(var x=0; x<balls.length; x++){
          if(Math.abs(balls[x].x-myGamePiece.x)<20 && Math.abs(balls[x].y-myGamePiece.y)<20&&balls[x].id!=myGamePiece.id){
            myGamePiece.hp-=5;
            balls.splice(x,1);
          }
      }
    }

    // checking if other ship was hit
    if(balls.length>0&&otherShips.length>0){
      for(var z=0; z<otherShips.length; z++){
        for(var x=0; x<balls.length; x++){
          if(Math.abs(balls[x].x-otherShips[z].x)<20 && Math.abs(balls[x].y-otherShips[z].y)<20&&balls[x].id!=otherShips[z].id){
            balls.splice(x,1);
          }
        }
      }
    }


    // checking if player died
    if(myGamePiece.hp<=0){
      myGamePiece = new myShip(Math.floor(Math.random()*1025), Math.floor(Math.random()*1025), person, tempId);
    }



}// end of game update



function myShip( x, y, name, id) {

    this.id=id;
    this.name=name;
    this.hp=100;
    this.inGame=false;

    this.speed = 0;
    this.angle = 0;
    this.moveAngle = 0;

    this.x = x;
    this.y = y;

    // shooting
    this.timerS=0;
    this.shot;

    this.update = function() {

        // for 4 ships only
        if(this.id<=numberOfPlayers){
          this.inGame=true;
        }else{
          this.inGame=false;
        }

        this.speed = 0;
        this.moveAngle = 0;

        // shooting and sending data
        if(this.inGame){
        // if in game
        if(myGameArea.keys && myGameArea.keys[32]&&this.timerS==0){
          this.shot={"x":round(this.x, 0),"y":round(this.y, 0),
          "a":round(this.angle+( (Math.round(Math.random() * (30)) - 15) * Math.PI / 180), 4)};

          this.timerS=10;

          if(this.id==1){
            socket.emit('data1', this.shot);
          }
          if(this.id==2){
            socket.emit('data2', this.shot);
          }
          if(this.id==3){
            socket.emit('data3', this.shot);
          }
          if(this.id==4){
            socket.emit('data4', this.shot);
          }
        }

        }

        if(this.timerS>0){
          this.timerS--;
        }

        if(this.inGame){
        // if in game
        if(myGameArea.keys && myGameArea.keys[40]){
          this.speed= 1;
        }
        if(myGameArea.keys && myGameArea.keys[38]){
          this.speed= -1;
        }
        if(myGameArea.keys && myGameArea.keys[37] ){
          this.moveAngle = -1;
        }
        if(myGameArea.keys && myGameArea.keys[39] ){
          this.moveAngle = 1;
        }

        }

        // moving as spectator
        if(this.id==200){
          if(myGameArea.keys && myGameArea.keys[40]){
            this.y+=3;
          }
          if(myGameArea.keys && myGameArea.keys[38]){
            this.y-=3;
          }
          if(myGameArea.keys && myGameArea.keys[37] ){
            this.x-=3;
          }
          if(myGameArea.keys && myGameArea.keys[39] ){
            this.x+=3;
          }
        }

        // map border detection
        if(myGamePiece.x<0){
          myGamePiece.x=0;
        }
        if(myGamePiece.x>1024){
          myGamePiece.x=1024;
        }
        if(myGamePiece.y<0){
          myGamePiece.y=0;
        }
        if(myGamePiece.y>1024){
          myGamePiece.y=1024;
        }

        if(this.inGame){

        // changing position
        this.angle += this.moveAngle * Math.PI / 180;
        this.x -= this.speed * Math.sin(this.angle);
        this.y += this.speed * Math.cos(this.angle);

        ctx = myGameArea.context;
        ctx.save();
        ctx.translate(window.innerWidth/2, window.innerHeight/2);
        ctx.rotate(this.angle);
        ctx.drawImage(pirate, -50, -50);
        //ctx.fillStyle = "red";
        //ctx.fillRect(30 / -2, 60 / -2, 30, 60);
        ctx.restore();

        ctx.font = "bold 20px Courier New";
        ctx.fillStyle = "white";
        ctx.fillText("HP:"+this.hp,window.innerWidth/2-30,window.innerHeight/2-50);
        ctx.fillText(this.name,window.innerWidth/2-30,window.innerHeight/2-80);
        ctx.fillText("ID:"+this.id,window.innerWidth/2-30,window.innerHeight/2-110);

        }

        if(!this.inGame){
          var info = "Connecting to game...";
          if(this.id==200){
            info = "Maximum players in game. You are spectator";
          }
          ctx = myGameArea.context;
          ctx.font = "bold 30px Courier New";
          ctx.fillStyle = "red";
          ctx.fillText(info,window.innerWidth/2-400,window.innerHeight/2-200);

        }

    }
}





function otherShip( x, y, a, id, name, hp) {

    this.id=id;
    this.name=name;
    this.hp=hp;

    this.speed = 0;
    this.angle = a;
    this.moveAngle = 0;

    this.x = x;
    this.y = y;
    this.targetX=x;
    this.targetY=y;


    // time before object will be removed
    this.timer=150;


    this.update = function(newX, newY, newA, newHp) {

      this.targetX = newX;
      this.targetY = newY;
      this.targetA = newA;
      this.hp=newHp;

      // if the ship is far away from its target move it directly
      if(Math.abs(newX-this.x)>50||Math.abs(newY-this.y)>50){
        this.x = newX;
        this.y = newY;
      }

      // if ship angle is very different to target angle for more then 0.5 radian change it directly
      if(Math.abs(newA-this.angle)>0.5){
        this.angle = newA;
      }

        this.timer=150;
    }


    this.show = function() {

      if(this.targetX>this.x){
        this.x+=1;
      }
      if(this.targetX<this.x){
        this.x-=1;
      }
      if(this.targetY>this.y){
        this.y+=1;
      }
      if(this.targetY<this.y){
        this.y-=1;
      }


      if(this.targetA>this.angle){
        this.moveAngle=1;
      }
      if(this.targetA<this.angle){
        this.moveAngle=-1;
      }
      if(Math.abs(this.targetA-this.angle)<0.05){
        this.moveAngle=0;
      }


      this.angle += this.moveAngle * Math.PI / 180;

      ctx = myGameArea.context;
      ctx.save();
      ctx.translate(window.innerWidth/2-myGamePiece.x+this.x,window.innerHeight/2-myGamePiece.y+this.y);
      ctx.rotate(this.angle);
      ctx.drawImage(pirate, -50, -50);
      //ctx.fillStyle = "blue";
      //ctx.fillRect(30 / -2, 60 / -2, 30, 60);
      ctx.restore();

      ctx.font = "bold 20px Courier New";
      ctx.fillStyle = "white";
      ctx.fillText("HP:"+this.hp,window.innerWidth/2-myGamePiece.x+this.x-30,window.innerHeight/2-myGamePiece.y+this.y-50);
      ctx.fillText(this.name,window.innerWidth/2-myGamePiece.x+this.x-30,window.innerHeight/2-myGamePiece.y+this.y-80);
      ctx.fillText("ID:"+this.id,window.innerWidth/2-myGamePiece.x+this.x-30,window.innerHeight/2-myGamePiece.y+this.y-110);

      this.timer--;

    }
}






function ball( x, y, a, id) {

    this.id=id;
    this.speed = 5;
    this.angle = a;
    this.timer=80
    this.x = x;
    this.y = y;


    this.show = function() {

      this.x += this.speed * Math.sin(this.angle);
      this.y -= this.speed * Math.cos(this.angle);

      ctx = myGameArea.context;
      ctx.save();
      ctx.translate(window.innerWidth/2-myGamePiece.x+this.x,window.innerHeight/2-myGamePiece.y+this.y);
      ctx.rotate(this.angle);
      ctx.beginPath();
      ctx.translate(0, 0);

      ctx.fillStyle = "black";

      ctx.arc(0, 0, 3, 0, 2*Math.PI);
      ctx.closePath();
      ctx.fill();
      ctx.restore();


      this.timer--;

    }
}




















//// MAIN GAME INTERVAL FUNCTION FOR CANVAS

function startGame() {
    myGameArea.start();
}


var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
        window.addEventListener('keyup', function (e) {
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
    },
    stop : function() {
        clearInterval(this.interval);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

</script>






</body>
</html>
